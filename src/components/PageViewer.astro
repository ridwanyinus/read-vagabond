---
export interface Props {
  pagesUrl: string[];
  volume: number;
  prevChapter: number | null;
  nextChapter: number | null;
}

const { pagesUrl, volume, prevChapter, nextChapter } = Astro.props;
---

<div
  class="min-h-screen bg-white flex flex-col items-center pt-20 md:pt-24"
  id="pageContainer"
  data-volume={volume}
  data-prev-chapter={prevChapter}
  data-next-chapter={nextChapter}
>
  <div class="w-full max-w-350 flex flex-col items-center">
    {
      pagesUrl.map((pageUrl, index) => (
        <img
          src={pageUrl}
          alt={`Page ${index + 1}`}
          class="h-auto max-h-screen block mb-0.5 object-contain border border-gray-900"
          loading={index < 3 ? "eager" : "lazy"}
          data-page={index}
        />
      ))
    }
  </div>
</div>

<script>
  import {
    currentPage,
    percentageRead,
    navbarVisibility,
  } from "../feature/reader/store";

  const container = document.getElementById("pageContainer") as HTMLElement;

  const volume = parseInt(container.dataset.volume!);
  const nextChapter =
    container.dataset.nextChapter == undefined
      ? null
      : parseInt(container.dataset.nextChapter);
  const prevChapter =
    container.dataset.prevChapter === undefined
      ? null
      : parseInt(container.dataset.prevChapter);

  const pages = document.querySelectorAll(
    "img[data-page]",
  ) as NodeListOf<HTMLElement>;
  const pageCount = pages.length;

  let lastScrollTop = 0;
  let hideTimeout = 0;

  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const pageIndex = Number((entry.target as HTMLElement).dataset.page);
          currentPage.set(pageIndex);
          percentageRead.set((pageIndex / pageCount) * 100);
        }
      });
    },
    { threshold: 0.6 },
  );

  pages.forEach((page) => observer.observe(page));

  window.addEventListener("scroll", () => {
    const scrollTop = window.scrollY || document.documentElement.scrollTop;

    if (scrollTop < lastScrollTop) {
      navbarVisibility.set("visible");
      clearTimeout(hideTimeout);
      hideTimeout = window.setTimeout(() => {
        navbarVisibility.set("hidden");
      }, 3000);
    } else {
      navbarVisibility.set("hidden");
    }

    lastScrollTop = scrollTop;
  });

  document.addEventListener("mousemove", () => {
    navbarVisibility.set("visible");
    clearTimeout(hideTimeout);
    hideTimeout = window.setTimeout(() => {
      navbarVisibility.set("hidden");
    }, 3000);
  });

  const scrollToPage = (index: number) => {
    if (index < 0 || index >= pages.length) return;

    window.scrollTo({
      top: pages[index].offsetTop,
      behavior: "smooth",
    });

    currentPage.set(index);
  };

  /* TODO: Maybe abstract this? */
  document.addEventListener("keydown", (e) => {
    const currentPageValue = currentPage.get();

    if (e.key === "ArrowDown" || e.key === "ArrowRight") {
      e.preventDefault();
      if (currentPageValue < pageCount - 1) {
        scrollToPage(currentPageValue + 1);
      } else if (nextChapter !== null) {
        window.location.href = `/volume-${volume}/chapter-${nextChapter}`;
      }
    } else if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
      e.preventDefault();
      if (currentPageValue > 0) {
        scrollToPage(currentPageValue - 1);
      } else if (prevChapter !== null) {
        window.location.href = `/volume-${volume}/chapter-${prevChapter}`;
      }
    }
  });
</script>
